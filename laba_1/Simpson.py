import math 

def f(x):
    #Вычисляемая функция
    return x**4 * math.log(x + math.sqrt(x**2 - 0.36), math.e)

def Simpson(a,b,N):
    #Шаг
    h=(b-a)/N
    #Вычисляем границы интеграла. Делаем это отдельно, так как для них нет коэфициентов
    Simpson_sum=f(a)+f(b)
    #запускаем цикл от 2 элемента до предпоследнего
    for i in range(1,N):
        #Если элемент чётный то умножаем функцию на 2, иначе на 4(коэфициенты константные)
        if i%2==0:
            Simpson_sum += 2*f(a+i*h)
        else:
            Simpson_sum += 4*f(a+i*h)
        #Возвращаем вычисленную сумму умноженную на h/3
    return Simpson_sum/3*h

def Runge(a,b,N,eps):
    #Вычисляем начальную сумму с кол-вом шагов 2
    S_old=Simpson(a,b,N)
    while True:
        #Увеличиваем кол-во шагов в 2 раза и вычисляем следующий интеграл
        N*=2
        S_new = Simpson(a,b,N)
        #Проверяем погрешность, если рассчитаная погрешность нас устраивает, то вывод, иначе первый интеграл меняем на только что вычисленный 
        if abs((S_new - S_old))/15 <= eps:
            return S_new, N
        else:
            S_old = S_new

a = 1.25 #float(input("Введите значение начала интегрирования: "))
b = 2.45 #float(input("Введите значение конца интегрирования: "))
N = 2 #int(input("Введите количество камней: "))
eps = 0.0001

result, new_n = Runge(a,b,N,eps)
print(f"Результат интегрирования {result:.5f}, шаги {new_n}")