def print_matrix(A):
    # Определяем функцию print_matrix, которая принимает матрицу A в качестве аргумента
    for i in A:
        # Проходим по каждой строке матрицы A
        for j in i:
            # Проходим по каждому элементу j в строке i
            print(j, " ", end="")
            # Печатаем элемент j с пробелом, не переходя на новую строку
        print("\n")
        # Печатаем новую строку после завершения печати строки матрицы
    for i in range(len(A) * 10):
        # Печатаем 10 символов "_" для разделения
        print("_", end="")
    print("\n")
    # Печатаем новую строку после завершения печати разделителей
    return
    # Завершаем выполнение функции

def regularization_tikhonov(A, b, alpha):
    """
    Решает систему линейных уравнений Ax = b методом регуляризации Тихонова.

    Параметры:
        A: Матрица коэффициентов.
        b: Вектор правой части.
        alpha: Параметр регуляризации.

    Возвращает:
        x: Решение системы.
    """
    # Получаем размерность матрицы A
    n = len(A)

    # Создаем матрицу регуляризации (alpha * I)
    I = [[0] * n for _ in range(n)]  # Инициализация единичной матрицы
    for i in range(n):
        I[i][i] = 1  # Заполнение диагонали единицами

    # Создаем матрицу A^T * A + alpha * I
    ATA = [[0] * n for _ in range(n)]  # Инициализация матрицы
    for i in range(n):
        for j in range(n):
            # Вычисляем A^T * A
            ATA[i][j] = sum(A[k][i] * A[k][j] for k in range(len(A)))

            # Добавляем alpha * I
            if i == j:
                ATA[i][j] += alpha

    # Создаем вектор b
    ATb = [0] * n  # Инициализация вектора
    for i in range(n):
        # Вычисляем A^T * b
        ATb[i] = sum(A[k][i] * b[k] for k in range(len(b)))

    # Решаем систему линейных уравнений (ATA)x = ATb
    # Используем метод Гаусса для решения
    x = [0] * n  # Инициализация решения
    for i in range(n):
        # Прямой ход
        for j in range(i + 1, n):
            if ATA[j][i] != 0:  # Проверка на ноль
                ratio = ATA[j][i] / ATA[i][i]  # Вычисляем коэффициент
                for k in range(n):
                    ATA[j][k] -= ratio * ATA[i][k]  # Обновляем строки
                ATb[j] -= ratio * ATb[i]  # Обновляем вектор правой части

    # Обратный ход
    for i in range(n - 1, -1, -1):
        x[i] = ATb[i]  # Начинаем с правой части
        for j in range(i + 1, n):
            x[i] -= ATA[i][j] * x[j]  # Вычитаем известные значения
        x[i] /= ATA[i][i]  # Делим на диагональный элемент

    return x

# Матрица коэффициентов (симметричная и положительно определенная)
A = [[3, 1, -1], [1, 5, -1], [20, 0, 3]]
# Определяем матрицу A
b = [-2, 8, 1]
# Определяем вектор b

# Параметр регуляризации
alpha = 0.00001
# Решение системы
x = regularization_tikhonov(A, b, alpha)

for i in range(len(A)):
    A[i].append(b[i])

print_matrix(A)
print("Решение:", x)