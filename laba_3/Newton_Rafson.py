import numpy as np # type: ignore
import matplotlib.pyplot as plt # type: ignore
import math

# Определение функций для системы уравнений
def eq1(x, y):
    return np.cos(y - 1) + x - 0.5  # Первое уравнение: cos(y-1) + x - 0.5 = 0

def eq2(x, y):
    return y - np.cos(x) - 3  # Второе уравнение: y - cos(x) - 3 = 0

# Создание сетки значений x и y для построения графиков
x = np.linspace(-10, 10, 400)  # Генерация 400 значений x от -10 до 10
y = np.linspace(-10, 10, 400)  # Генерация 400 значений y от -10 до 10
X, Y = np.meshgrid(x, y)  # Создание сетки координат из векторов x и y

# Вычисление значений функций на сетке
Z1 = eq1(X, Y)  # Вычисление значений первого уравнения на сетке
Z2 = eq2(X, Y)  # Вычисление значений второго уравнения на сетке

# Построение графиков
plt.figure(figsize=(50, 50))  # Установка размера графика

# График первого уравнения: cos(y-1) + x = 0.5
plt.contour(X, Y, Z1, levels=[0], colors='blue', label=r'$\cos(y-1) + x = 0.5$')

# График второго уравнения: y - cos(x) = 3
plt.contour(X, Y, Z2, levels=[0], colors='red', label=r'$y - \cos(x) = 3$')

# Настройка графика
plt.xlabel('x')  # Подпись оси x
plt.ylabel('y')  # Подпись оси y
plt.title('График системы уравнений')  # Заголовок графика
plt.axhline(0, color='black', linewidth=0.5)  # Горизонтальная линия на уровне y=0
plt.axvline(0, color='black', linewidth=0.5)  # Вертикальная линия на уровне x=0
plt.grid(True)  # Включение сетки
plt.legend()  # Отображение легенды

# Отображение графика
plt.show()

# Определение системы уравнений
def equations(vars):
    x, y = vars  # Распаковка переменных из списка
    eq1 = math.cos(y - 1) + x - 0.5  # Вычисление первого уравнения
    eq2 = y - math.cos(x) - 3  # Вычисление второго уравнения
    return [eq1, eq2]  # Возврат значений уравнений

# Вычисление матрицы Якоби (частные производные)
def jacobian(vars):
    x, y = vars  # Распаковка переменных из списка
    # Частные производные для первого уравнения
    df1_dx = 1  # Частная производная по x
    df1_dy = -math.sin(y - 1)  # Частная производная по y
    # Частные производные для второго уравнения
    df2_dx = math.sin(x)  # Частная производная по x
    df2_dy = 1  # Частная производная по y
    return [[df1_dx, df1_dy], [df2_dx, df2_dy]]  # Возврат матрицы Якоби

# Метод Ньютона-Рафсона
def newton_raphson(equations, jacobian, initial_guess, tol=0.0001, max_iter=100):
    vars = initial_guess  # Начальное приближение
    for i in range(max_iter):  # Цикл по максимальному количеству итераций
        # Вычисляем значения уравнений и матрицы Якоби
        F = equations(vars)  # Вычисление значений уравнений
        J = jacobian(vars)  # Вычисление матрицы Якоби
        
        # Решаем систему линейных уравнений J * delta = -F
        # Используем метод Крамера для 2x2 системы
        det = J[0][0] * J[1][1] - J[0][1] * J[1][0]  # Вычисление определителя матрицы Якоби
        if det == 0:  # Проверка на вырождение матрицы
            raise ValueError("Матрица Якоби вырождена")  # Исключение при вырождении
        
        # Вычисление изменений переменных
        delta_x = (-F[0] * J[1][1] + F[1] * J[0][1]) / det  # Изменение x
        delta_y = (F[0] * J[1][0] - F[1] * J[0][0]) / det  # Изменение y
        
        # Обновляем переменные
        vars = [vars[0] + delta_x, vars[1] + delta_y]  # Обновление значений переменных
        
        # Проверка на сходимость
        if math.sqrt(delta_x**2 + delta_y**2) < tol:  # Условие сходимости
            print(f"Решение сошлось за {i + 1} итераций.")  # Вывод информации о сходимости
            return vars  # Возврат найденного решения
    
    print("Метод не сошелся за максимальное количество итераций.")  # Сообщение о не сходимости
    return vars  # Возврат последнего значения переменных

# Начальное приближение
initial_guess = [1.0, 1.0]  # Задание начального приближения для метода

# Решение системы
solution = newton_raphson(equations, jacobian, initial_guess)  # Вызов метода Ньютона-Рафсона
print("Решение:", solution)  # Вывод найденного решения