import math 

# Функция, минимум которой нужно найти
def f(x):
    return 2**x-4*x

# Обратная квадратичная интерполяция для поиска минимума
def inverse_quadratic_interpolation_min(f, x1, x2, x3, tol=0.0001, max_iter=100):
    """
    Поиск минимума функции с использованием обратной квадратичной интерполяции.

    Параметры:
        f: Функция, минимум которой нужно найти.
        x1, x2, x3: Начальные точки.
        tol: Точность (критерий остановки).
        max_iter: Максимальное количество итераций.

    Возвращает:
        x_min: Приближение к точке минимума.
    """
    for i in range(max_iter):
        # Вычисляем значения функции в точках
        f1, f2, f3 = f(x1), f(x2), f(x3)
        
        # Коэффициенты квадратичной аппроксимации
        denominator = ((x1**2 - x2**2) * (x2 - x3) - (x2**2 - x3**2) * (x1 - x2))
        if abs(denominator) < 1e-10:  # Проверка на близость к нулю
            # Если знаменатель близок к нулю, используем другой метод обновления точек
            x_new = (x1 + x2 + x3) / 3  # Простое среднее значение
        else:
            A = ((f2 - f3) * (x1 - x2) - (f1 - f2) * (x2 - x3)) / denominator
            B = ((f1 - f2) - A * (x1**2 - x2**2)) / (x1 - x2)
            C = f1 - A * x1**2 - B * x1
        
            # Минимум квадратичной аппроксимации
            if abs(A) < 1e-10:  # Проверка на близость к нулю
                x_new = (x1 + x2 + x3) / 3  # Простое среднее значение
            else:
                x_new = -B / (2 * A)
        
        # Проверка, что x_new находится внутри интервала [x1, x3]
        if x_new < x1 or x_new > x3:
            x_new = (x1 + x3) / 2  # Используем середину интервала
        
        # Проверка на сходимость
        if abs(x_new - x2) < tol:
            print(f"Решение сошлось за {i + 1} итераций.")
            return x_new
        
        # Обновление точек
        if x_new < x2:
            x1, x2, x3 = x1, x_new, x2
        else:
            x1, x2, x3 = x2, x_new, x3
    
    print("Метод не сошелся за максимальное количество итераций.")
    return x2

# Пример использования

    # Начальные точки (выбираем вблизи предполагаемого минимума)
x1, x2, x3 = 2, 2.5, 3
    
    # Поиск минимума
x_min = inverse_quadratic_interpolation_min(f, x1, x2, x3)
print("Минимум функции находится в точке:", x_min)
print("Значение функции в минимуме:", f(x_min))

# Визуализация
import matplotlib.pyplot as plt

x_plot = [i * 0.1 for i in range(0, 50)]  # Точки для построения графика
y_plot = [f(x) for x in x_plot]  # Значения функции

plt.figure(figsize=(10, 6))
plt.plot(x_plot, y_plot, label='Функция: $2^x-4x$')
plt.scatter(x_min, f(x_min), color='red', label='Минимум')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Поиск минимума функции методом обратной квадратичной интерполяции')
plt.legend()
plt.grid(True)
plt.show()